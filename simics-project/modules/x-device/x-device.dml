/*
  Â© 2016 Intel Corporation
*/

// This is an incomplete X device module to learn how to translate 
//specifications to dml code. 

dml 1.4;

device x_device;

param desc = "example X device";

param documentation =
    "X device incomplete for dml workshop. Find the specification "
    + "on the documentation";

import "utility.dml";


//Libraries for interfaces
import "simics/devs/signal.dml";
import "simics/devs/memory-space.dml";
import "../control_Device_PCI-interface/control_Device_PCI-interface.dml";

header %{
#include <stdio.h>
#include <stdlib.h>
%}

extern FILE * fopen(const char *, const char *);
extern int fgetc(FILE *);
extern int ftell(FILE *);
extern int fclose(FILE *);
extern int fseek(FILE *,  int, int);
extern typedef struct { } FILE;


param BUFFER_SIZE = 3000000;
session FILE * file;

param byte_order = "little-endian";
param path_img = "../../img.bmp";

// Memory-space connection
connect target_mem_space {
    param documentation =
        "The memory space on which the X device operates. Data will be "
        + "read from and copied to the memory associated with this memory "
        + "space.";
    param configuration = "required";
    interface memory_space;
}

bank regs is function_mapped_bank{

    param function = 1;

    param register_size = 4;
    register buffer_size size register_size @ 0x00{
        is read_only;
        param init_val = BUFFER_SIZE;
    }

    register cmd size register_size @ 0x04{
        is write;
        is read;
        param init_val = 0x00;
        method write(uint64 value){
            default(value);
            local uint32 index = 0;
            local uint32 size_img = 0;
            if (value == 0x1){
                file = fopen(path_img, "rb");
                fseek(file, 0, 2);
                size_img = ftell(file);
                fseek(file, 0, 0);
                file_size.val = size_img;
                log info, 4: "image size = %d", size_img;
                for (index = 0; index < file_size.val; index++) {
                    local uint8 char_read = fgetc(file);
                    buffer[index].set_val(char_read);
                    if(index < 15){
                        log info, 4: "loaded val = 0x%x @ buffer[%d]", char_read, index;
                    }
                }
                fclose(file);
            }
        }
    }

    register file_size size register_size @ 0x08{
        is read;
        is write;
        param init_val = 0x00;
    }
    register buffer[i < BUFFER_SIZE + 1] size register_size @ i * 4 + 0x12{
        is read_only;
        param init_val = 0x00;
    }

}

port control_in {

    param desc = "Control X-Device from PCI";

    implement control_Device_PCI {

        method start_operation(){

            log info, 4: "Receving a request";

        }

    }

}


