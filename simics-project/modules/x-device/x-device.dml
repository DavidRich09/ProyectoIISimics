/*
  Â© 2016 Intel Corporation
*/

// This is an incomplete X device module to learn how to translate 
//specifications to dml code. 

dml 1.4;

device x_device;

param desc = "example X device";

param documentation =
    "X device incomplete for dml workshop. Find the specification "
    + "on the documentation";

import "utility.dml";


//Libraries for interfaces
import "simics/devs/signal.dml";
import "simics/devs/memory-space.dml";
import "../control_Device_PCI-interface/control_Device_PCI-interface.dml";

header %{
#include <stdio.h>
#include <stdlib.h>
%}

extern FILE * fopen(const char *, const char *);
extern int fgetc(FILE *);
extern int ftell(FILE *);
extern int fclose(FILE *);
extern int fseek(FILE *,  int, int);
extern typedef struct { } FILE;


param BUFFER_SIZE = 256;
session FILE * file;

param byte_order = "little-endian";

// Memory-space connection
connect target_mem_space {
    param documentation =
        "The memory space on which the X device operates. Data will be "
        + "read from and copied to the memory associated with this memory "
        + "space.";
    param configuration = "required";
    interface memory_space;
}


attribute img_path {
    param type = "s";
    session char* val;
    session int len;
    //get handler, gets called with called from CLI or the get interface
    method get() -> (attr_value_t) default {
        return SIM_make_attr_string(val != NULL ? val : "");
      
    }

    //set handler, gets called with called from CLI or the set interface
    method set(attr_value_t attr) throws default {
        local const char* attr_str = SIM_attr_string(attr);
        set_string(attr_str);

    }

    /* 
        set_string: copies the parmater char * to the internal char structure
        the old stored value is deleted 
    */
    method set_string(const char *ptr) {
        if (len > 0) {delete val;}
        len = strlen(ptr);
        val = new char[len + 1];
        strcpy(val, ptr);
    }
} 

bank regs is function_mapped_bank{

    param function = 1;
    param register_size = 4;
    param register_buffer_size = 1;

    /**
    This register is used to store the size of the buffer.
    */

    register buffer_size size register_size @ 0x00{
        is read;
        is write;
        param init_val = 0x0;
    }

    /**
    This register is used to store the command that will be executed.
    */

    register cmd size register_size @ 0x04{
        is write;
        is read;
        param init_val = 0x00;
        /**
        This method is used to write the cmd register.
        If the value is 0x1, the open_file method is called.
        If the value is 0x2, the read_file method is called.
        params: uint64 value
        return: None
        */
        method write(uint64 value){
            log info, 4: "writting %d in cmd", value;
            default(value);
            if (value == 0x1){
                open_file();
            } else if (value == 0x2){
                read_file();
            }
        }
    }

    /**
    This register is used to store the size of the img file that will be loaded in the buffer.
    */

    register file_size size register_size @ 0x08{
        is read_only;
        param init_val = 0x00;
    }

    /**
    This register is used to store the offset of the file that will be read.
    */

    register file_offset size register_size @ 0x12{
        is read;
        is write;
        param init_val = 0x00;
    }

    /**
    This register is used to store the path of the img file that will be loaded in the buffer.
    */

    register buffer[i < BUFFER_SIZE] size register_buffer_size @ i + 0x16{
        is read_only;
        param init_val = 0x00;
    }

    /**
    This method open the img and get the file size then save it in file_size register.
    Also reset file_offset register to 0.
    params: None
    return: None
    */

    method open_file(){
        if(img_path.val != NULL){
            file_offset.set_val(0);
            file = fopen(img_path.val, "rb");
            fseek(file, 0, 2);
            local uint32 size_img = ftell(file);
            fseek(file, 0, 0);
            file_size.val = size_img;
            log info, 4: "Img size = %d", size_img;
            fclose(file);
        } else{
            log error, 4: "No img path";
        }
    }

    /**
    This method read 256 bytes from the img file and save it in the buffer.
    Also increment the file_offset register by 256 and verify if the file is not at the end.
    params: None
    return: None    
    */
    method read_file(){
        file = fopen(img_path.val, "rb");
        fseek(file, file_offset.val, 0);
        for (local uint32 index = 0; index < 256 && index + file_offset.val < file_size.val; index++) {
            local uint8 char_read = fgetc(file);
            buffer[index].set_val(char_read);
            buffer_size.set_val(buffer_size.get() + 1);
            if(index < 15){
                log info, 3: "Value buffer loaded = 0x%x @ buffer[%d]", char_read, index;
            }
        }
        file_offset.set_val(file_offset.get_val()  + 256);
        fclose(file);
    }


}

/**
This is for communication with the PCI device.
*/

implement control_Device_PCI {

    /**
    This method is used to start write in cmd register.
    params: uint32 value
    return: None
    */
    method start_read(uint32 value){
        log info, 4: "Device Interface in start_read %d", value;
        regs.cmd.write(value);
    }

    /**
    This method is used to read the buffer register at the index.
    params: uint16 index
    return: uint16
    */

    method read_buffer(uint16 index) -> (uint16){
        return regs.buffer[index].get_val();
    }

    /**
    This method is used to write in cmd register to move the offset and continue reading the file.
    params: None
    return: None
    */

    method move_offeset(){
        regs.cmd.write(0x2);
    }


    /**
    This method is used to read the file size register.
    params: None
    return: uint32
    */

    method read_file_size() -> (uint32){
        return regs.file_size.get_val();
    }

}


