/*
  Device PCI data capture
  This simulated PCI device recieves a file path in the attribute and displays the
  first 8 bytes of the attribute file as a parameter.

  This Software is part of Simics. The rights to copy, distribute,
  modify, or otherwise make use of this Software may be licensed only
  pursuant to the terms of an applicable license agreement.
  
  Copyright 2010-2021 Intel Corporation

*/

dml 1.4;


device pci_data_capture;
import "utility.dml";

//Libraries for interfaces
import "simics/devs/signal.dml";
import "simics/devs/memory-space.dml";
import "../control_Device_PCI-interface/control_Device_PCI-interface.dml";

param desc = "PCI data capture";
param documentation = "This simulated PCI device recieves a file path in the attribute and displays the first 8 bytes of the attribute file";

//this header statement imports header libraries from C directly
header %{
#include <stdio.h>
#include <stdlib.h>
%}

/*
    imports the basic pci functionality
    template is applied for the pci_device 
*/
import "pci/common.dml";
is pci_device;

param pci_hotplug = true;

// constant size of buffer
param BUFFER_SIZE = 256;

bank pci_config {

    /* This attribute should contain a list of all BAR registers */
    param base_address_registers = ["base_address_0"];
 
    register vendor_id { param init_val = 0x104C; } // Texas Instruments
    register device_id { param init_val = 0xAC10; } // PC Card Controller

    register base_address_0 @ 0x10 is (memory_base_address_32) {
        param size_bits = 18;
        param map_func = 1;
    }
    register base_address_1 @ 0x14 is (no_base_address_32);
    register base_address_2 @ 0x18 is (no_base_address_32);
    register base_address_3 @ 0x1C is (no_base_address_32);
    register base_address_4 @ 0x20 is (no_base_address_32);
    register base_address_5 @ 0x24 is (no_base_address_32);
}

bank regs is function_mapped_bank {
    /* Each register bank need to have a unique function number,
       which should match with the map_func param in one BAR */
    param function = 1;

    /**
    This register is used to store the file size of the file that is read from the device
    */

    register file_size size 4 @ 0x0 {
        param init_val = 0x0;
    }

    /**
    This register is used to store the buffer size
    */

    register buf_size size 4 @ 0x4 {
        param init_val = BUFFER_SIZE;
    }
    
    /**
    This register is used to store the command that will be executed.
    */

    register cmd size 4 @ 0x14 {
        is write;
        is read;
        param init_val = 0x0;
        
        /**
        This method is used to write the cmd register
        If the value is 0x1, the device will start reading the file
        If the value is 0x2, the device will read the buffer from the device
        If the value is 0x3, the device will read the file size from the device
        param: int64 value
        return: None
        */
        method write(uint64 value) {
            default(value);
            local uint32 index = 0;
            log info, 4: "The PCI recieves the operation: %d", value;
            if (value == 0x1) {
                log info, 4: "PCI operation: %d", value;
                conexion_to_Device.start_read(value);
            } else if(value == 0x2){
                log info, 4: "PCI operation: %d", value;
                conexion_to_Device.read_buffer_device();
            } else if (value == 0x3){
                log info, 4: "PCI operation: %d", value;
                conexion_to_Device.read_file_size();              
            }

        }
    }
    
    //for communicating initial 8 bytes of the file after command=1 and input attr value is populated
    register buffer[i < BUFFER_SIZE] size 1 @ 0x18 + i {
        is read;
        is write;
        param init_val = 0x0;
    }
}

/**
Connects the PCI device to the control_Device_PCI interface
*/

connect conexion_to_Device {

    param internal = false;

    interface control_Device_PCI {
        param required = true;
    }

    /**
    This method is used to start the read operation
    param: uint32 value
    return: None
    */

    method start_read(uint32 value){
        if(!obj){
            log error: "Model setup is inconsistent! (connect %s has no object)", 
                       this.qname; 
            return;
        }
        this.control_Device_PCI.start_read(value);
    }

    /**
    This method is used to read the buffer from the device and say move the offset
    return: None
    */


    method read_buffer_device(){
        if(!obj){
            log error: "Model setup is inconsistent! (connect %s has no object)", 
                       this.qname; 
            return;
        }
        local uint16 index = 0;
        this.control_Device_PCI.move_offeset();
        for(index = 0; index < BUFFER_SIZE; index++){
            regs.buffer[index].set_val(this.control_Device_PCI.read_buffer(index));
        }
        log info, 4: "End read buffer device";   
    }

    /**
    This method is used to read the file size from the device and save it in the register file_size
    param: None
    return: None
    */

    method read_file_size(){
        if(!obj){
            log error: "Model setup is inconsistent! (connect %s has no object)", 
                       this.qname; 
            return;
        }
        regs.file_size.set_val(this.control_Device_PCI.read_file_size());
    }
}
